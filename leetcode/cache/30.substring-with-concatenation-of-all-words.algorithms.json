{"id":30,"fid":"30","name":"串联所有单词的子串","slug":"substring-with-concatenation-of-all-words","link":"https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/","percent":38.974000091281134,"level":"Hard","category":"algorithms","en_name":"Substring with Concatenation of All Words","cn_name":"串联所有单词的子串","totalAC":"205.2K","totalSubmit":"526.3K","likes":1109,"dislikes":0,"desc":"<p>给定一个字符串&nbsp;<code>s</code><strong>&nbsp;</strong>和一个字符串数组&nbsp;<code>words</code><strong>。</strong>&nbsp;<code>words</code>&nbsp;中所有字符串 <strong>长度相同</strong>。</p>\n\n<p>&nbsp;<code>s</code><strong>&nbsp;</strong>中的 <strong>串联子串</strong> 是指一个包含&nbsp;&nbsp;<code>words</code>&nbsp;中所有字符串以任意顺序排列连接起来的子串。</p>\n\n<ul>\n\t<li>例如，如果&nbsp;<code>words = [\"ab\",\"cd\",\"ef\"]</code>， 那么&nbsp;<code>\"abcdef\"</code>，&nbsp;<code>\"abefcd\"</code>，<code>\"cdabef\"</code>，&nbsp;<code>\"cdefab\"</code>，<code>\"efabcd\"</code>， 和&nbsp;<code>\"efcdab\"</code> 都是串联子串。&nbsp;<code>\"acdbef\"</code> 不是串联子串，因为他不是任何&nbsp;<code>words</code>&nbsp;排列的连接。</li>\n</ul>\n\n<p>返回所有串联子串在&nbsp;<code>s</code><strong>&nbsp;</strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n<code><strong>输出：</strong>[]</code>\n<strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n<strong>输出：</strong>[6,9,12]\n<strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code>&nbsp;和&nbsp;<code>s</code> 由小写英文字母组成</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n\n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:"},{"value":"c","text":"C","defaultCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n\n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function findSubstring(s: string, words: string[]): number[] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $words\n     * @return Integer[]\n     */\n    function findSubstring($s, $words) {\n\n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun findSubstring(s: String, words: Array<String>): List<Int> {\n\n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<int> findSubstring(String s, List<String> words) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func findSubstring(s string, words []string) []int {\n\n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {String} s\n# @param {String[]} words\n# @return {Integer[]}\ndef find_substring(s, words)\n\nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def findSubstring(s: String, words: Array[String]): List[Int] = {\n        \n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n\n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (find-substring s words)\n  (-> string? (listof string?) (listof exact-integer?))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec find_substring(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> [integer()].\nfind_substring(S, Words) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec find_substring(s :: String.t, words :: [String.t]) :: [integer]\n  def find_substring(s, words) do\n    \n  end\nend"}],"testcase":"\"barfoothefoobarman\"\n[\"foo\",\"bar\"]","testable":true,"templateMeta":{"name":"findSubstring","params":[{"name":"s","type":"string"},{"name":"words","type":"string[]"}],"return":{"type":"list<integer>"}}}