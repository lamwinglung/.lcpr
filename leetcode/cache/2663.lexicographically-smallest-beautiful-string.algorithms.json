{"id":2687,"fid":"2663","name":"字典序最小的美丽字符串","slug":"lexicographically-smallest-beautiful-string","link":"https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/description/","percent":44.96418979409132,"level":"Hard","category":"algorithms","en_name":"Lexicographically Smallest Beautiful String","cn_name":"字典序最小的美丽字符串","totalAC":"9.7K","totalSubmit":"15.9K","likes":40,"dislikes":0,"desc":"<p>如果一个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li>它由英语小写字母表的前 <code>k</code> 个字母组成。</li>\n\t<li>它不包含任何长度为 <code>2</code> 或更长的回文子字符串。</li>\n</ul>\n\n<p>给你一个长度为 <code>n</code> 的美丽字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>请你找出并返回一个长度为 <code>n</code> 的美丽字符串，该字符串还满足：在字典序大于 <code>s</code> 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果字符串 <code>a</code> 在与字符串 <code>b</code> 不同的第一个位置上的字符字典序更大，则字符串 <code>a</code> 的字典序大于字符串 <code>b</code> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abcd\"</code> 的字典序比 <code>\"abcc\"</code> 更大，因为在不同的第一个位置（第四个字符）上 <code>d</code> 的字典序大于 <code>c</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcz\", k = 26\n<strong>输出：</strong>\"abda\"\n<strong>解释：</strong>字符串 \"abda\" 既是美丽字符串，又满足字典序大于 \"abcz\" 。\n可以证明不存在字符串同时满足字典序大于 \"abcz\"、美丽字符串、字典序小于 \"abda\" 这三个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dc\", k = 4\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>可以证明，不存在既是美丽字符串，又字典序大于 \"dc\" 的字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>4 &lt;= k &lt;= 26</code></li>\n\t<li><code>s</code> 是一个美丽字符串</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    string smallestBeautifulString(string s, int k) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public String smallestBeautifulString(String s, int k) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def smallestBeautifulString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:"},{"value":"c","text":"C","defaultCode":"char * smallestBeautifulString(char * s, int k){\n\n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public string SmallestBeautifulString(string s, int k) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar smallestBeautifulString = function(s, k) {\n\n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function smallestBeautifulString(s: string, k: number): string {\n\n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return String\n     */\n    function smallestBeautifulString($s, $k) {\n\n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func smallestBeautifulString(_ s: String, _ k: Int) -> String {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun smallestBeautifulString(s: String, k: Int): String {\n\n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  String smallestBeautifulString(String s, int k) {\n\n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func smallestBeautifulString(s string, k int) string {\n\n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {String} s\n# @param {Integer} k\n# @return {String}\ndef smallest_beautiful_string(s, k)\n\nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def smallestBeautifulString(s: String, k: Int): String = {\n\n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn smallest_beautiful_string(s: String, k: i32) -> String {\n\n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (smallest-beautiful-string s k)\n  (-> string? exact-integer? string?)\n\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec smallest_beautiful_string(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\nsmallest_beautiful_string(S, K) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec smallest_beautiful_string(s :: String.t, k :: integer) :: String.t\n  def smallest_beautiful_string(s, k) do\n\n  end\nend"}],"testcase":"\"abcz\"\n26","testable":true,"templateMeta":{"name":"smallestBeautifulString","params":[{"name":"s","type":"string"},{"type":"integer","name":"k"}],"return":{"type":"string"}}}